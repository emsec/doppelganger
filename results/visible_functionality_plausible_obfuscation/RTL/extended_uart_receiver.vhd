library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use IEEE.math_real.all;

----------------------------------------------
-- VHDL code generated by MHDL v0.1.3.4
----------------------------------------------

entity Extended_UART_Receiver is
    generic (
        CLK_FREQUENCY : natural;
        BAUD_RATE     : natural;
        BUS_SIZE      : natural
    );
    port (
        CLK                : in  std_logic;
        RST                : in  std_logic;
        RS232_BIT          : in  std_logic;
        write_to_bus       : in  std_logic;
        bus_line           : out std_logic_vector (BUS_SIZE - 1 downto 0);
        available          : out std_logic;
        byte_available     : out std_logic;
        last_received_byte : out std_logic_vector (7 downto 0)
    );
end Extended_UART_Receiver;

architecture arch of Extended_UART_Receiver is
    component UART_Receiver
        generic (
            CLK_FREQUENCY : natural;
            BAUD_RATE     : natural
        );
        port (
            CLK        : in  std_logic;
            RST        : in  std_logic;
            RS232_BIT  : in  std_logic;
            DATA_OUT   : out std_logic_vector (7 downto 0);
            DATA_VALID : out std_logic
        );
    end component;
    type fsm_1_state is (S_RESET, S_WAIT_DATA, S_UPDATE_REGISTER, S_READY);
    
    signal CNT_EN                   : std_logic;
    signal CNT_RST                  : std_logic;
    signal COUNT                    : natural range 0 to BUS_SIZE / 8 + 1;
    signal REG                      : std_logic_vector (BUS_SIZE - 1 downto 0);
    signal REG_EN                   : std_logic;
    signal fsm_1_current_state      : fsm_1_state;
    signal fsm_1_next_state         : fsm_1_state;
    signal inst_receiver_DATA_OUT   : std_logic_vector (7 downto 0);
    signal inst_receiver_DATA_VALID : std_logic;
begin
    inst_receiver : UART_Receiver
    generic map (
        CLK_FREQUENCY => CLK_FREQUENCY,
        BAUD_RATE     => BAUD_RATE
    )
    port map (
        CLK        => CLK,
        RST        => RST,
        RS232_BIT  => RS232_BIT,
        DATA_OUT   => inst_receiver_DATA_OUT,
        DATA_VALID => inst_receiver_DATA_VALID
    );
    
    bus_line <= REG when (write_to_bus = '1') else (OTHERS => 'Z');
    last_received_byte <= inst_receiver_DATA_OUT;
    byte_available <= inst_receiver_DATA_VALID;
    process(CLK)
    begin
        if rising_edge(CLK) then
            if (CNT_RST = '1') then
                COUNT <= 0;
            elsif (CNT_EN = '1') then
                COUNT <= COUNT + 1;
            end if;
            if (REG_EN = '1') then
                REG <= REG((BUS_SIZE) - 9 downto 0) & inst_receiver_DATA_OUT;
            end if;
        end if;
    end process;
    
    process(CLK)
    begin
        if rising_edge(CLK) then
            if (RST = '1') then
                fsm_1_current_state <= S_RESET;
            else
                fsm_1_current_state <= fsm_1_next_state;
            end if;
        end if;
    end process;
    process(count, inst_receiver_data_valid, fsm_1_current_state)
    begin
        -- default assignments
        fsm_1_next_state <= fsm_1_current_state;
        CNT_RST <= '0';
        CNT_EN <= '0';
        REG_EN <= '0';
        available <= '0';
        -- state transitions
        case fsm_1_current_state is
            when S_RESET =>
                CNT_RST <= '1';
                fsm_1_next_state <= S_WAIT_DATA;
                ----------------------------------------
            when S_WAIT_DATA =>
                if (inst_receiver_DATA_VALID = '1') then
                    fsm_1_next_state <= S_UPDATE_REGISTER;
                    CNT_EN <= '1';
                end if;
                ----------------------------------------
            when S_UPDATE_REGISTER =>
                REG_EN <= '1';
                if (COUNT = BUS_SIZE / 8) then
                    fsm_1_next_state <= S_READY;
                else
                    fsm_1_next_state <= S_WAIT_DATA;
                end if;
                ----------------------------------------
            when S_READY =>
                available <= '1';
                CNT_RST <= '1';
                fsm_1_next_state <= S_WAIT_DATA;
                ----------------------------------------
        end case;
    end process;
    
end arch;

