library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use IEEE.math_real.all;

----------------------------------------------
-- VHDL code generated by MHDL v0.1.3.4
----------------------------------------------

entity UART_Receiver is
    generic (
        CLK_FREQUENCY : natural;
        BAUD_RATE     : natural
    );
    port (
        CLK        : in  std_logic;
        RST        : in  std_logic;
        RS232_BIT  : in  std_logic;
        DATA_OUT   : out std_logic_vector (7 downto 0);
        DATA_VALID : out std_logic
    );
end UART_Receiver;

architecture arch of UART_Receiver is
    type fsm_1_state is (S_RESET, S_WAIT_DATA, S_SAMPLING, S_READY);
    
    constant BIT_RECEIVING_TIME : natural := CLK_FREQUENCY / BAUD_RATE;
    
    signal BIT_CNT             : natural range 0 to 9;
    signal CLK_CNT             : natural range 0 to BIT_RECEIVING_TIME;
    signal CNT_EN              : std_logic;
    signal CNT_RST             : std_logic;
    signal REG                 : std_logic_vector (7 downto 0);
    signal REG_EN              : std_logic;
    signal RS232_BIT_LAST      : std_logic;
    signal RS232_BIT_SYN       : std_logic;
    signal fsm_1_current_state : fsm_1_state;
    signal fsm_1_next_state    : fsm_1_state;
begin
    DATA_OUT <= REG;
    process(CLK)
    begin
        if rising_edge(CLK) then
            if (RST = '1') then
                RS232_BIT_SYN <= '0';
                RS232_BIT_LAST <= '0';
            else
                RS232_BIT_SYN <= RS232_BIT;
                RS232_BIT_LAST <= RS232_BIT_SYN;
            end if;
            if (CNT_RST = '1') then
                CLK_CNT <= 0;
                BIT_CNT <= 0;
            elsif (CNT_EN = '1') then
                if (CLK_CNT < BIT_RECEIVING_TIME) then
                    CLK_CNT <= CLK_CNT + 1;
                else
                    CLK_CNT <= 0;
                    BIT_CNT <= BIT_CNT + 1;
                end if;
            end if;
            if (REG_EN = '1') then
                REG <= RS232_BIT & REG(7 downto 1);
            end if;
        end if;
    end process;
    
    process(CLK)
    begin
        if rising_edge(CLK) then
            if (RST = '1') then
                fsm_1_current_state <= S_RESET;
            else
                fsm_1_current_state <= fsm_1_next_state;
            end if;
        end if;
    end process;
    process(rs232_bit_last, rs232_bit_syn, bit_cnt, clk_cnt, fsm_1_current_state)
    begin
        -- default assignments
        fsm_1_next_state <= fsm_1_current_state;
        CNT_EN <= '0';
        CNT_RST <= '0';
        REG_EN <= '0';
        DATA_VALID <= '0';
        -- state transitions
        case fsm_1_current_state is
            when S_RESET =>
                CNT_RST <= '1';
                fsm_1_next_state <= S_WAIT_DATA;
                ----------------------------------------
            when S_WAIT_DATA =>
                if ((RS232_BIT_SYN = '0') and (RS232_BIT_LAST = '1')) then
                    fsm_1_next_state <= S_SAMPLING;
                end if;
                ----------------------------------------
            when S_SAMPLING =>
                if (CLK_CNT = BIT_RECEIVING_TIME / 2) then
                    REG_EN <= '1';
                end if;
                if (BIT_CNT = 9) then
                    fsm_1_next_state <= S_READY;
                else
                    CNT_EN <= '1';
                end if;
                ----------------------------------------
            when S_READY =>
                DATA_VALID <= '1';
                CNT_RST <= '1';
                fsm_1_next_state <= S_WAIT_DATA;
                ----------------------------------------
        end case;
    end process;
    
end arch;

