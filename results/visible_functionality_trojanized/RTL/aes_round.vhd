library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use IEEE.math_real.all;

----------------------------------------------
-- VHDL code generated by MHDL v0.1.3.4
----------------------------------------------

entity AESRoundFunction is
    port (
        counter   : in  unsigned(3 downto 0);
        state     : in  std_logic_vector (127 downto 0);
        roundkey  : in  std_logic_vector (127 downto 0);
        new_state : out std_logic_vector (127 downto 0)
    );
end AESRoundFunction;

architecture arch of AESRoundFunction is
    component MixSingleColumn
        port (
            input  : in  std_logic_vector (31 downto 0);
            output : out std_logic_vector (31 downto 0)
        );
    end component;
    signal a0_0              : std_logic_vector (7 downto 0);
    signal a0_1              : std_logic_vector (7 downto 0);
    signal a0_2              : std_logic_vector (7 downto 0);
    signal a0_3              : std_logic_vector (7 downto 0);
    signal a1_0              : std_logic_vector (7 downto 0);
    signal a1_1              : std_logic_vector (7 downto 0);
    signal a1_2              : std_logic_vector (7 downto 0);
    signal a1_3              : std_logic_vector (7 downto 0);
    signal a2_0              : std_logic_vector (7 downto 0);
    signal a2_1              : std_logic_vector (7 downto 0);
    signal a2_2              : std_logic_vector (7 downto 0);
    signal a2_3              : std_logic_vector (7 downto 0);
    signal a3_0              : std_logic_vector (7 downto 0);
    signal a3_1              : std_logic_vector (7 downto 0);
    signal a3_2              : std_logic_vector (7 downto 0);
    signal a3_3              : std_logic_vector (7 downto 0);
    signal after_addRoundKey : std_logic_vector (127 downto 0);
    signal after_mixColumns  : std_logic_vector (127 downto 0);
    signal after_shiftRows   : std_logic_vector (127 downto 0);
    signal after_subBytes    : std_logic_vector (127 downto 0);
    signal inst_mc0_output   : std_logic_vector (31 downto 0);
    signal inst_mc1_output   : std_logic_vector (31 downto 0);
    signal inst_mc2_output   : std_logic_vector (31 downto 0);
    signal inst_mc3_output   : std_logic_vector (31 downto 0);
begin
    inst_mc0 : MixSingleColumn
    port map (
        input  => after_shiftRows(127 downto 96),
        output => inst_mc0_output
    );
    
    inst_mc1 : MixSingleColumn
    port map (
        input  => after_shiftRows(95 downto 64),
        output => inst_mc1_output
    );
    
    inst_mc2 : MixSingleColumn
    port map (
        input  => after_shiftRows(63 downto 32),
        output => inst_mc2_output
    );
    
    inst_mc3 : MixSingleColumn
    port map (
        input  => after_shiftRows(31 downto 0),
        output => inst_mc3_output
    );
    
    after_addRoundKey <= state xor roundkey;
    gen : for i in 16 downto 1 generate sbox : entity work . AES_Sbox port map (a => after_addRoundKey(i * 8 - 1 downto(i - 1) * 8), b => after_subBytes(i * 8 - 1 downto(i - 1) * 8));
end generate;

a0_0 <= after_subBytes(127 downto 120);
a1_0 <= after_subBytes(119 downto 112);
a2_0 <= after_subBytes(111 downto 104);
a3_0 <= after_subBytes(103 downto 96);
a0_1 <= after_subBytes(95 downto 88);
a1_1 <= after_subBytes(87 downto 80);
a2_1 <= after_subBytes(79 downto 72);
a3_1 <= after_subBytes(71 downto 64);
a0_2 <= after_subBytes(63 downto 56);
a1_2 <= after_subBytes(55 downto 48);
a2_2 <= after_subBytes(47 downto 40);
a3_2 <= after_subBytes(39 downto 32);
a0_3 <= after_subBytes(31 downto 24);
a1_3 <= after_subBytes(23 downto 16);
a2_3 <= after_subBytes(15 downto 8);
a3_3 <= after_subBytes(7 downto 0);
after_shiftRows <= a0_0 & a1_1 & a2_2 & a3_3 & a0_1 & a1_2 & a2_3 & a3_0 & a0_2 & a1_3 & a2_0 & a3_1 & a0_3 & a1_0 & a2_1 & a3_2;
after_mixColumns <= inst_mc0_output & inst_mc1_output & inst_mc2_output & inst_mc3_output;
new_state <= after_shiftRows when (counter = "1001") else after_addRoundKey when (counter = "1010") else after_mixColumns;
end arch;

